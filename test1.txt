#!/usr/bin/env python3
"""
WSO2 API Manager 4.2 - Policy Endpoint Extractor
Fixed version - Basic Auth with individual resources
"""

import requests
import json
import base64
import os
from datetime import datetime
import urllib3
import zipfile
import gzip
import io
import csv
import sys
import re
import yaml

def create_config():
    config = {
        "publisher_url": "https://localhost:9443",
        "username": "admin",
        "password": "admin",
        "verify_ssl": False,
        "output_csv": "wso2_policy_endpoints.csv",
        "instructions": {
            "publisher_url": "WSO2 API Manager base URL",
            "username": "WSO2 username with admin/publisher access",
            "password": "WSO2 password",
            "verify_ssl": "Set to false for self-signed certificates"
        }
    }
    
    with open("policy_config.json", 'w') as f:
        json.dump(config, f, indent=4)
    print("Config file created: policy_config.json")
    print("Please update with your WSO2 details")

class WSO2APIManager:
    def __init__(self):
        with open("policy_config.json", 'r') as f:
            self.config = json.load(f)
        
        self.base_url = self.config['publisher_url'].rstrip('/')
        self.username = self.config['username']
        self.password = self.config['password']
        self.verify_ssl = self.config.get('verify_ssl', True)
        
        self.session = requests.Session()
        self.session.verify = self.verify_ssl
        
        if not self.verify_ssl:
            urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
        
        # Use basic authentication only
        auth_header = base64.b64encode(f"{self.username}:{self.password}".encode()).decode()
        self.auth_header = f"Basic {auth_header}"
        
        self.publisher_url = f"{self.base_url}/api/am/publisher/v4"
        print("Using Basic Authentication")
    
    def get_api_headers(self):
        return {
            'Authorization': self.auth_header,
            'Content-Type': 'application/json'
        }
    
    def get_all_apis(self):
        try:
            url = f"{self.publisher_url}/apis"
            headers = self.get_api_headers()
            
            all_apis = []
            offset = 0
            limit = 500
            
            while True:
                params = {'limit': limit, 'offset': offset}
                response = self.session.get(url, headers=headers, params=params)
                
                if response.status_code == 200:
                    data = response.json()
                    apis = data.get('list', [])
                    all_apis.extend(apis)
                    
                    print(f"Retrieved {len(apis)} APIs (offset: {offset})")
                    
                    if len(apis) < limit:
                        break
                    offset += limit
                else:
                    print(f"Failed to get APIs: {response.status_code} - {response.text}")
                    break
            
            print(f"Total APIs found: {len(all_apis)}")
            return all_apis
        except Exception as e:
            print(f"Error getting APIs: {str(e)}")
            return []
    
    def get_api_details(self, api_id):
        try:
            url = f"{self.publisher_url}/apis/{api_id}"
            headers = self.get_api_headers()
            response = self.session.get(url, headers=headers)
            
            if response.status_code == 200:
                return response.json()
            else:
                print(f"Failed to get API details for {api_id}: {response.status_code}")
                return None
        except Exception as e:
            print(f"Error getting API details for {api_id}: {str(e)}")
            return None
    
    def get_mediation_policies(self, api_id):
        """Get API-level mediation policies"""
        try:
            url = f"{self.publisher_url}/apis/{api_id}/mediation-policies"
            headers = self.get_api_headers()
            response = self.session.get(url, headers=headers)
            
            if response.status_code == 200:
                return response.json()
            return {'list': []}
        except Exception as e:
            return {'list': []}
    
    def get_operation_policies(self, api_id):
        """Get operation-level policies for an API"""
        try:
            url = f"{self.publisher_url}/apis/{api_id}/operation-policies"
            response = self.session.get(url, headers=self.get_api_headers())
            if response.status_code == 200:
                return response.json().get('list', [])
            else:
                print(f"Failed to fetch operation policies for {api_id}: {response.status_code}")
                return []
        except Exception as e:
            print(f"Error fetching operation policies for {api_id}: {str(e)}")
            return []
    
    def get_operation_policy_content(self, api_id, policy_id):
        try:
            url = f"{self.publisher_url}/apis/{api_id}/operation-policies/{policy_id}/content"
            response = self.session.get(url, headers=self.get_api_headers())
            if response.status_code == 200:
                return response.content
            return None
        except Exception as e:
            return None
    
    def download_mediation_policy(self, api_id, policy_id):
        try:
            url = f"{self.publisher_url}/apis/{api_id}/mediation-policies/{policy_id}/content"
            headers = self.get_api_headers()
            response = self.session.get(url, headers=headers)
            
            if response.status_code == 200:
                return response.text
            return None
        except Exception as e:
            return None
    
    def decompress_policy_content(self, compressed_content):
        """Decompress policy content (handles ZIP and GZIP) - Prioritize YAML for NEW APIs"""
        if not compressed_content:
            return None
            
        # Try ZIP decompression first
        try:
            with zipfile.ZipFile(io.BytesIO(compressed_content), 'r') as zip_file:
                file_list = zip_file.namelist()
                print(f"ZIP contains: {file_list}")
                
                # For NEW APIs - Look for YAML files FIRST (contains actual rootHost values)
                # NEW APIs have policy names like: 1VitalitySetRootHostA11MANDATORY
                has_new_api_policy = any('vitality' in filename.lower() and 'roothost' in filename.lower() 
                                       for filename in file_list)
                
                if has_new_api_policy:
                    print("Detected NEW API policy - prioritizing YAML files")
                    # Look for YAML files first for NEW APIs
                    for filename in file_list:
                        if filename.endswith('.yaml') or filename.endswith('.yml'):
                            try:
                                with zip_file.open(filename) as file:
                                    yaml_content = file.read().decode('utf-8')
                                    print(f"Extracted YAML from {filename} for NEW API")
                                    return yaml_content
                            except Exception as e:
                                print(f"Error extracting YAML {filename}: {e}")
                                pass
                
                # For OLD APIs or if no YAML found - Look for J2 files first
                for filename in file_list:
                    if filename.endswith('.j2'):
                        try:
                            with zip_file.open(filename) as file:
                                j2_content = file.read().decode('utf-8')
                                print(f"Extracted J2 template from {filename}")
                                return j2_content
                        except:
                            pass
                
                # Then look for XML files
                for filename in file_list:
                    if filename.endswith('.xml'):
                        try:
                            with zip_file.open(filename) as file:
                                xml_content = file.read().decode('utf-8')
                                print(f"Extracted XML from {filename}")
                                return xml_content
                        except:
                            pass
                
                # Then YAML files (for OLD APIs or fallback)
                for filename in file_list:
                    if filename.endswith('.yaml') or filename.endswith('.yml'):
                        try:
                            with zip_file.open(filename) as file:
                                yaml_content = file.read().decode('utf-8')
                                print(f"Extracted YAML from {filename}")
                                return yaml_content
                        except:
                            pass
                
                # If no specific files, get the first file
                if file_list:
                    with zip_file.open(file_list[0]) as file:
                        content = file.read().decode('utf-8')
                        print(f"Extracted content from {file_list[0]}")
                        return content
                        
        except zipfile.BadZipFile:
            pass  # Not a ZIP file, try GZIP
        except Exception as e:
            print(f"ZIP extraction error: {str(e)}")
        
        # Try GZIP decompression
        try:
            decompressed = gzip.decompress(compressed_content)
            content = decompressed.decode('utf-8')
            print("Successfully decompressed with GZIP")
            return content
        except:
            pass  # Not GZIP either
        
        # Try as plain text
        try:
            content = compressed_content.decode('utf-8')
            print("Content is plain text")
            return content
        except:
            pass
        
        return None
    
    def download_operation_policy_content(self, api_id, policy_id):
        try:
            compressed_content = self.get_operation_policy_content(api_id, policy_id)
            if compressed_content:
                return self.decompress_policy_content(compressed_content)
            return None
        except Exception as e:
            return None
    
    def extract_roothost_from_policy_content(self, policy_content, policy_name):
        if not policy_content:
            return "", "no_content"
        
        try:
            roothost_value = ""
            endpoint_type = "unknown"
            
            print(f"Analyzing policy: {policy_name}")
            print(f"Content length: {len(policy_content)}")
            print(f"Content preview: {policy_content[:400]}...")
            
            # Debug: Check what type of content we have
            has_operation_policies = 'operationPolicies:' in policy_content
            has_parameters = 'parameters:' in policy_content
            has_templates = '{{' in policy_content or '${' in policy_content
            
            print(f"DEBUG - has_operation_policies: {has_operation_policies}")
            print(f"DEBUG - has_parameters: {has_parameters}")
            print(f"DEBUG - has_templates: {has_templates}")
            
            # For NEW APIs - ONLY look for actual URL values, NOT templates
            if has_operation_policies or has_parameters:
                print("Processing as NEW API content...")
                
                # Pattern 1: Direct rootHost: URL extraction (most reliable)
                roothost_url_patterns = [
                    r'rootHost:\s*(https?://[^\s\n\r\'"<>{}$]+)',  # rootHost: https://url (no templates)
                    r'rootHost:\s*["\']*(https?://[^\s\n\r\'"<>{}$]+)["\']?',  # rootHost: "https://url"
                    r'roothost:\s*(https?://[^\s\n\r\'"<>{}$]+)',  # case insensitive
                    r'roothost:\s*["\']*(https?://[^\s\n\r\'"<>{}$]+)["\']?',  # case insensitive with quotes
                    r'ROOT_HOST:\s*(https?://[^\s\n\r\'"<>{}$]+)',  # uppercase
                    r'ROOT_HOST:\s*["\']*(https?://[^\s\n\r\'"<>{}$]+)["\']?',  # uppercase with quotes
                ]
                
                for i, pattern in enumerate(roothost_url_patterns):
                    print(f"DEBUG - Trying NEW API pattern {i+1}: {pattern}")
                    matches = re.findall(pattern, policy_content, re.IGNORECASE | re.MULTILINE)
                    if matches:
                        print(f"DEBUG - Pattern {i+1} found matches: {matches}")
                        for match in matches:
                            # Clean the match
                            clean_match = match.strip().strip('"\'').strip()
                            print(f"DEBUG - Evaluating match: '{clean_match}'")
                            # Only accept actual URLs, not templates
                            if (clean_match.startswith('http') and 
                                '{{' not in clean_match and 
                                '${' not in clean_match and
                                len(clean_match) > 10):
                                roothost_value = clean_match
                                endpoint_type = "operation_policy_yaml_roothost"
                                print(f"✅ Found rootHost URL pattern: {roothost_value}")
                                return roothost_value, endpoint_type
                            else:
                                print(f"❌ Rejected match: {clean_match} (not valid URL or contains templates)")
                
                # Pattern 2: Look for any standalone HTTP/HTTPS URLs in NEW API content
                print("DEBUG - Trying standalone URL pattern for NEW API...")
                url_pattern = r'(https?://[^\s\n\r\'"<>{}$]+[^\s\n\r\'"<>{}$\.,])'
                matches = re.findall(url_pattern, policy_content, re.IGNORECASE)
                if matches:
                    print(f"DEBUG - Found URLs: {matches}")
                    for url in matches:
                        # Filter out templates and common non-endpoint URLs
                        if (not any(skip in url.lower() for skip in ['{{', '${', 'localhost', 'example.com', 'docs.', 'swagger']) 
                            and len(url) > 10):
                            roothost_value = url.strip()
                            endpoint_type = "operation_policy_yaml_roothost"
                            print(f"✅ Found standalone URL in NEW API content: {roothost_value}")
                            return roothost_value, endpoint_type
                        else:
                            print(f"❌ Rejected URL: {url} (contains templates or is documentation)")
                
                # Pattern 3: Try YAML parsing for structured content
                print("DEBUG - Trying YAML parsing for NEW API...")
                try:
                    yaml_content = yaml.safe_load(policy_content)
                    if isinstance(yaml_content, dict):
                        print(f"DEBUG - YAML parsed successfully, keys: {list(yaml_content.keys())}")
                        # Look for operation policies with parameters
                        if 'operationPolicies' in yaml_content:
                            op_policies = yaml_content['operationPolicies']
                            if 'request' in op_policies:
                                request_policies = op_policies['request']
                                print(f"DEBUG - Request policies type: {type(request_policies)}")
                                # Handle both list and single policy formats
                                if isinstance(request_policies, list):
                                    for j, policy in enumerate(request_policies):
                                        print(f"DEBUG - Checking policy {j}: {policy.get('policyName', 'Unknown')}")
                                        if 'parameters' in policy and 'rootHost' in policy['parameters']:
                                            candidate = policy['parameters']['rootHost']
                                            print(f"DEBUG - Found rootHost candidate: '{candidate}'")
                                            # Only accept actual URLs, not templates
                                            if isinstance(candidate, str) and candidate.startswith('http') and '{{' not in candidate:
                                                roothost_value = candidate
                                                endpoint_type = "operation_policy_yaml_roothost"
                                                print(f"✅ Found YAML rootHost parameter (list): {roothost_value}")
                                                return roothost_value.strip(), endpoint_type
                                            else:
                                                print(f"❌ Rejected YAML candidate: {candidate} (not valid URL or contains templates)")
                                elif isinstance(request_policies, dict):
                                    print(f"DEBUG - Request policies is dict: {request_policies.keys()}")
                                    if 'parameters' in request_policies and 'rootHost' in request_policies['parameters']:
                                        candidate = request_policies['parameters']['rootHost']
                                        print(f"DEBUG - Found rootHost candidate: '{candidate}'")
                                        # Only accept actual URLs, not templates
                                        if isinstance(candidate, str) and candidate.startswith('http') and '{{' not in candidate:
                                            roothost_value = candidate
                                            endpoint_type = "operation_policy_yaml_roothost"
                                            print(f"✅ Found YAML rootHost parameter (dict): {roothost_value}")
                                            return roothost_value.strip(), endpoint_type
                                        else:
                                            print(f"❌ Rejected YAML candidate: {candidate} (not valid URL or contains templates)")
                        
                        # Also check direct parameters section
                        if 'parameters' in yaml_content and 'rootHost' in yaml_content['parameters']:
                            candidate = yaml_content['parameters']['rootHost']
                            print(f"DEBUG - Found direct rootHost candidate: '{candidate}'")
                            # Only accept actual URLs, not templates
                            if isinstance(candidate, str) and candidate.startswith('http') and '{{' not in candidate:
                                roothost_value = candidate
                                endpoint_type = "operation_policy_yaml_roothost"
                                print(f"✅ Found YAML rootHost parameter (direct): {roothost_value}")
                                return roothost_value.strip(), endpoint_type
                            else:
                                print(f"❌ Rejected direct YAML candidate: {candidate} (not valid URL or contains templates)")
                                
                except yaml.YAMLError as e:
                    print(f"DEBUG - YAML parsing failed: {e}")
                except Exception as e:
                    print(f"DEBUG - YAML processing error: {e}")
                
                print("❌ No actual URL values found in NEW API content - returning empty")
                # For NEW APIs, if we can't find actual URL, don't return template values
                return "", "no_content"
            
            # For OLD APIs (mediation policies) - can accept various formats
            else:
                print("Processing as OLD API content...")
                
                # Pattern 1: Look for rootHost in J2 template files (for mediation policies)
                j2_patterns = [
                    r'rootHost["\s]*[=:]["\s]*([^"\s\n\r}]+)',  # rootHost = "value" or rootHost: "value"
                    r'roothost["\s]*[=:]["\s]*([^"\s\n\r}]+)',  # case insensitive
                    r'ROOT_HOST["\s]*[=:]["\s]*([^"\s\n\r}]+)', # uppercase
                    r'root_host["\s]*[=:]["\s]*([^"\s\n\r}]+)', # underscore
                ]
                
                for pattern in j2_patterns:
                    matches = re.findall(pattern, policy_content, re.IGNORECASE | re.MULTILINE)
                    if matches:
                        roothost_value = matches[0].strip().strip('"\'')
                        endpoint_type = "mediation_policy_j2_roothost"
                        print(f"Found J2 rootHost: {roothost_value}")
                        return roothost_value, endpoint_type
                
                # Pattern 2: XML property format (for XML-based mediation policies)
                xml_property_patterns = [
                    r'<property[^>]*name=["\']rootHost["\'][^>]*value=["\']([^"\']+)["\']',
                    r'<property[^>]*name=["\']roothost["\'][^>]*value=["\']([^"\']+)["\']',
                    r'<property[^>]*name=["\']root_host["\'][^>]*value=["\']([^"\']+)["\']',
                    r'<property[^>]*name=["\']ROOT_HOST["\'][^>]*value=["\']([^"\']+)["\']',
                ]
                
                for pattern in xml_property_patterns:
                    matches = re.findall(pattern, policy_content, re.IGNORECASE | re.DOTALL)
                    if matches:
                        roothost_value = matches[0]
                        endpoint_type = "mediation_policy_xml_property"
                        print(f"Found XML rootHost property: {roothost_value}")
                        return roothost_value, endpoint_type
                
                # Pattern 3: Hardcoded URLs in address elements
                url_patterns = [
                    r'<address\s+uri=["\']([^"\']+)["\']',
                    r'<endpoint[^>]*>.*?<address[^>]+uri=["\']([^"\']+)["\']',
                    r'<http[^>]*>.*?<uri-template[^>]*>([^<]+)</uri-template>',
                    r'uri["\s]*[=:]["\s]*([^"\s\n\r}]+)',  # For J2 files
                ]
                
                for pattern in url_patterns:
                    matches = re.findall(pattern, policy_content, re.IGNORECASE | re.DOTALL)
                    if matches:
                        roothost_value = matches[0]
                        endpoint_type = "mediation_policy_hardcoded_url"
                        print(f"Found hardcoded URL: {roothost_value}")
                        return roothost_value, endpoint_type
                
                # Pattern 4: Template variables in J2 files (for OLD APIs only)
                print("DEBUG - Checking for templates in OLD API content...")
                template_patterns = [
                    r'\{\{([^}]*[Rr]oot[Hh]ost[^}]*)\}\}',  # {{ rootHost }}
                    r'\{\{([^}]*[Hh]ost[^}]*)\}\}',         # {{ host }}
                    r'\{\{([^}]*[Ee]ndpoint[^}]*)\}\}',     # {{ endpoint }}
                    r'\$\{([^}]*[Rr]oot[Hh]ost[^}]*)\}',   # ${ rootHost }
                    r'\$\{([^}]*[Hh]ost[^}]*)\}',          # ${ host }
                ]
                
                for pattern in template_patterns:
                    matches = re.findall(pattern, policy_content, re.IGNORECASE)
                    if matches:
                        match = matches[0]
                        if 'roothost' in match.lower() or 'host' in match.lower():
                            if '{{' in policy_content:
                                roothost_value = f"{{{{{match}}}}}"
                            else:
                                roothost_value = f"${{{match}}}"
                            endpoint_type = "mediation_policy_j2_template"
                            print(f"Found J2 template variable (OLD API): {roothost_value}")
                            return roothost_value, endpoint_type
                
                # Pattern 5: Look for any HTTP/HTTPS URLs in OLD API content (general fallback)
                general_url_pattern = r'https?://[^\s<>"\'}\)]+[^\s<>"\'}\)\.,]'
                matches = re.findall(general_url_pattern, policy_content)
                if matches:
                    roothost_value = matches[0]
                    endpoint_type = "mediation_policy_general_url"
                    print(f"Found general URL: {roothost_value}")
                    return roothost_value, endpoint_type
            
            print(f"❌ No rootHost value found in policy content")
            return "", "no_content"
            
        except Exception as e:
            print(f"❌ Error extracting roothost from {policy_name}: {str(e)}")
            return "", "extraction_error"
    
    def analyze_api(self, api_id, api_name, api_version):
        results = []
        
        try:
            api_details = self.get_api_details(api_id)
            if not api_details:
                return results
            
            # Get backend endpoint
            backend_url = ""
            has_backend_conf = False
            backend_endpoints = api_details.get('endpointConfig', {})
            if backend_endpoints:
                production_endpoints = backend_endpoints.get('production_endpoints', {})
                if production_endpoints:
                    backend_url = production_endpoints.get('url', '')
                    has_backend_conf = bool(backend_url)
            
            operations = api_details.get('operations', [])
            
            if not operations:
                results.append({
                    'api_id': api_id,
                    'api_name': api_name,
                    'api_version': api_version,
                    'api_context': api_details.get('context', ''),
                    'resource_path': 'N/A',
                    'resource_method': 'N/A',
                    'current_endpoint': backend_url,
                    'new_endpoint': backend_url,
                    'endpoint_type': 'no_operations',
                    'api_type': 'no_operations_defined',
                    'policy_name': 'N/A',
                    'policy_attribute': 'N/A',
                    'operation_policy_count': 0,
                    'has_backend_conf': has_backend_conf,
                    'has_policy_parameter': False
                })
                return results
            
            # Get API-level mediation policies first (but don't use them for processing)
            api_mediation_policies = self.get_mediation_policies(api_id)
            print(f"  Found {len(api_mediation_policies.get('list', []))} API-level mediation policies")
            
            # Process each operation/resource individually
            for operation in operations:
                resource_path = operation.get('target', '/')
                resource_method = operation.get('verb', 'GET')
                operation_policies = operation.get('operationPolicies', {})
                
                request_policies = operation_policies.get('request', [])
                response_policies = operation_policies.get('response', [])
                all_operation_policies = request_policies + response_policies
                operation_policy_count = len(all_operation_policies)
                
                has_policy_parameter = False
                found_endpoint = False
                
                print(f"  Processing resource: {resource_method} {resource_path}")
                
                # Check for operation-level policies (NEW APIs)
                if all_operation_policies:
                    print(f"    Found {len(all_operation_policies)} operation policies")
                    for policy in all_operation_policies:
                        policy_id = policy.get('policyId', '')
                        policy_name = policy.get('policyName', '')
                        
                        if policy_id:
                            policy_content = self.download_operation_policy_content(api_id, policy_id)
                            
                            if policy_content:
                                if 'parameter' in policy_content.lower() or 'param' in policy_content.lower():
                                    has_policy_parameter = True
                                
                                roothost_value, endpoint_type = self.extract_roothost_from_policy_content(policy_content, policy_name)
                                
                                if roothost_value:
                                    # Determine API type with correct endpoint types
                                    if 'yaml' in endpoint_type.lower() and 'roothost' in endpoint_type.lower():
                                        api_type = "operation_policy_based"
                                        final_endpoint_type = "operation_parameter"  # NEW APIs - rootHost from api.yaml
                                    elif 'template' in endpoint_type.lower() or 'dynamic' in endpoint_type.lower():
                                        api_type = "operation_policy_based"
                                        final_endpoint_type = "operation_policy_dynamic_template"
                                    elif 'hardcoded' in endpoint_type.lower():
                                        api_type = "operation_policy_based"
                                        final_endpoint_type = "operation_policy_hardcoded_url"
                                    else:
                                        api_type = "operation_policy_based"
                                        final_endpoint_type = "operation_parameter"  # Default for NEW APIs
                                    
                                    results.append({
                                        'api_id': api_id,
                                        'api_name': api_name,
                                        'api_version': api_version,
                                        'api_context': api_details.get('context', ''),
                                        'resource_path': resource_path,
                                        'resource_method': resource_method,
                                        'current_endpoint': roothost_value,
                                        'new_endpoint': roothost_value,
                                        'endpoint_type': final_endpoint_type,
                                        'api_type': api_type,
                                        'policy_name': policy_name,
                                        'policy_attribute': 'operation_policy',
                                        'operation_policy_count': operation_policy_count,
                                        'has_backend_conf': has_backend_conf,
                                        'has_policy_parameter': has_policy_parameter
                                    })
                                    found_endpoint = True
                                    break  # Found endpoint for this resource, move to next resource
                
                # If no operation policies found, check for attached mediation policies (OLD APIs)
                if not found_endpoint:
                    print(f"    No operation policies found, checking attached mediation policies...")
                    
                    # For old APIs, check each mediation policy from the API-level list
                    if api_mediation_policies.get('list'):
                        for policy in api_mediation_policies['list']:
                            policy_id = policy.get('id', '')
                            policy_name = policy.get('name', '')
                            
                            if policy_id:
                                print(f"    Checking mediation policy: {policy_name}")
                                policy_content = self.download_mediation_policy(api_id, policy_id)
                                
                                if policy_content:
                                    print(f"    Downloaded policy content ({len(policy_content)} chars)")
                                    roothost_value, endpoint_type = self.extract_roothost_from_policy_content(policy_content, policy_name)
                                    
                                    if roothost_value:
                                        # Determine API type for mediation policies - OLD APIs
                                        api_type = "mediation_policy_based"
                                        final_endpoint_type = "operation_policy_hardcoded_url"  # OLD APIs - all mediation policies
                                        
                                        results.append({
                                            'api_id': api_id,
                                            'api_name': api_name,
                                            'api_version': api_version,
                                            'api_context': api_details.get('context', ''),
                                            'resource_path': resource_path,
                                            'resource_method': resource_method,
                                            'current_endpoint': roothost_value,
                                            'new_endpoint': roothost_value,
                                            'endpoint_type': final_endpoint_type,
                                            'api_type': api_type,
                                            'policy_name': policy_name,
                                            'policy_attribute': 'mediation_policy',
                                            'operation_policy_count': 1,
                                            'has_backend_conf': has_backend_conf,
                                            'has_policy_parameter': bool('parameter' in str(policy_content).lower())
                                        })
                                        found_endpoint = True
                                        print(f"    Found rootHost in mediation policy: {roothost_value}")
                                        break  # Found endpoint for this resource, move to next resource
                                else:
                                    print(f"    Failed to download policy content for: {policy_name}")
                    else:
                        print(f"    No mediation policies found at API level")
                
                # If still no endpoint found, use backend or mark as no endpoint
                if not found_endpoint:
                    print(f"    No policies with rootHost found, checking backend configuration")
                    if backend_url:
                        results.append({
                            'api_id': api_id,
                            'api_name': api_name,
                            'api_version': api_version,
                            'api_context': api_details.get('context', ''),
                            'resource_path': resource_path,
                            'resource_method': resource_method,
                            'current_endpoint': backend_url,
                            'new_endpoint': backend_url,
                            'endpoint_type': 'backend_config',  # WSO2 production endpoint
                            'api_type': 'backend_endpoint_based',
                            'policy_name': 'N/A',
                            'policy_attribute': 'N/A',
                            'operation_policy_count': 0,
                            'has_backend_conf': has_backend_conf,
                            'has_policy_parameter': False
                        })
                    else:
                        results.append({
                            'api_id': api_id,
                            'api_name': api_name,
                            'api_version': api_version,
                            'api_context': api_details.get('context', ''),
                            'resource_path': resource_path,
                            'resource_method': resource_method,
                            'current_endpoint': '',
                            'new_endpoint': '',
                            'endpoint_type': 'no_endpoint',  # No endpoint or rootHost found
                            'api_type': 'no_endpoint_configured',
                            'policy_name': 'N/A',
                            'policy_attribute': 'N/A',
                            'operation_policy_count': 0,
                            'has_backend_conf': has_backend_conf,
                            'has_policy_parameter': False
                        })
        
        except Exception as e:
            print(f"Error analyzing API {api_id}: {str(e)}")
            results.append({
                'api_id': api_id,
                'api_name': api_name,
                'api_version': api_version,
                'api_context': api_details.get('context', ''),
                'resource_path': 'ERROR',
                'resource_method': 'ERROR',
                'current_endpoint': '',
                'new_endpoint': '',
                'endpoint_type': 'analysis_error',
                'api_type': 'error',
                'policy_name': 'ERROR',
                'policy_attribute': 'ERROR',
                'operation_policy_count': 0,
                'has_backend_conf': False,
                'has_policy_parameter': False
            })
        
        return results
    
    def process_all_apis(self):
        try:
            print("Starting API discovery...")
            all_apis = self.get_all_apis()
            if not all_apis:
                return [], []
            
            all_results = []
            total_apis = len(all_apis)
            processed_count = 0
            error_count = 0
            total_resources = 0
            
            print(f"Processing {total_apis} APIs for individual resource analysis...")
            
            for i, api in enumerate(all_apis, 1):
                api_id = api.get('id', '')
                api_name = api.get('name', 'Unknown')
                api_version = api.get('version', '1.0.0')
                
                print(f"[{i}/{total_apis}] Processing: {api_name}")
                
                try:
                    api_results = self.analyze_api(api_id, api_name, api_version)
                    if api_results:
                        all_results.extend(api_results)
                        total_resources += len(api_results)
                        processed_count += 1
                        print(f"  Found {len(api_results)} resources")
                    else:
                        error_count += 1
                        print(f"  No results for {api_name}")
                except Exception as e:
                    error_count += 1
                    print(f"  Error processing {api_name}: {str(e)}")
                
                # Progress update every 50 APIs
                if i % 50 == 0:
                    print(f"  Progress: {i}/{total_apis} APIs processed ({(i/total_apis)*100:.1f}%)")
                    print(f"  Resources found so far: {total_resources}")
            
            print(f"\nAPI Processing Complete!")
            print(f"Successfully processed: {processed_count}/{total_apis} APIs")
            print(f"Total resources found: {total_resources}")
            print(f"Errors encountered: {error_count}")
            
            return all_results, all_apis
            
        except Exception as e:
            print(f"Error processing APIs: {str(e)}")
            return [], []
    
    def save_to_csv(self, data, output_file):
        try:
            if not data:
                print("No data to save")
                return
            
            fieldnames = [
                'api_id', 'api_name', 'api_version', 'api_context', 'resource_path', 'resource_method',
                'current_endpoint', 'new_endpoint', 'endpoint_type', 'api_type', 'policy_name',
                'policy_attribute', 'operation_policy_count', 'has_backend_conf', 'has_policy_parameter'
            ]
            
            with open(output_file, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()
                writer.writerows(data)
            
            print(f"Data saved to {output_file}")
        except Exception as e:
            print(f"Error saving CSV: {str(e)}")
    
    def generate_detailed_report(self, data, all_apis):
        """Generate detailed statistics report"""
        print("\n" + "="*80)
        print("DETAILED WSO2 API MANAGER EXTRACTION REPORT")
        print("="*80)
        
        # Basic Statistics
        print(f"\nBASIC STATISTICS:")
        print(f"Total APIs searched: {len(all_apis)}")
        print(f"Total APIs processed successfully: {len(set(d['api_id'] for d in data))}")
        print(f"Total API resources found: {len(data)}")
        
        # Policy Statistics
        operation_policies = [d for d in data if d.get('policy_attribute') == 'operation_policy']
        mediation_policies = [d for d in data if d.get('policy_attribute') == 'mediation_policy']
        no_policies = [d for d in data if d.get('policy_attribute') == 'N/A']
        
        print(f"\nPOLICY STATISTICS:")
        print(f"Resources with Mediation Policies (OLD): {len(mediation_policies)}")
        print(f"Resources with NO Policies: {len(no_policies)}")
        
        # Endpoint Statistics
        roothost_policies = [d for d in data if 'roothost' in d.get('endpoint_type', '').lower()]
        template_policies = [d for d in data if 'dynamic' in d.get('endpoint_type', '').lower()]
        hardcoded_policies = [d for d in data if 'hardcoded' in d.get('endpoint_type', '').lower()]
        backend_only = [d for d in data if d.get('endpoint_type') == 'backend_config']
        no_endpoints = [d for d in data if 'no_endpoint' in d.get('endpoint_type', '')]
        
        print(f"\nENDPOINT STATISTICS:")
        print(f"Resources with RootHost parameters: {len(roothost_policies)}")
        print(f"Resources with Template variables: {len(template_policies)}")
        print(f"Resources with Hardcoded URLs: {len(hardcoded_policies)}")
        print(f"Resources with Backend endpoints only: {len(backend_only)}")
        print(f"Resources with NO endpoints: {len(no_endpoints)}")
        
        # RootHost Details
        if roothost_policies:
            print(f"\nROOTHOST POLICY DETAILS:")
            roothost_values = {}
            for policy in roothost_policies:
                endpoint = policy.get('current_endpoint', 'N/A')
                if endpoint in roothost_values:
                    roothost_values[endpoint] += 1
                else:
                    roothost_values[endpoint] = 1
            
            print(f"Unique RootHost values found: {len(roothost_values)}")
            for endpoint, count in sorted(roothost_values.items(), key=lambda x: x[1], reverse=True)[:10]:
                print(f"  {endpoint}: {count} resources")
        
        # Success Rate
        errors = [d for d in data if d.get('endpoint_type') == 'analysis_error']
        successful_resources = len(data) - len(errors)
        success_rate = (successful_resources / len(data)) * 100 if data else 0
        
        print(f"\nSUCCESS METRICS:")
        print(f"Successful resource analysis: {successful_resources}/{len(data)} ({success_rate:.1f}%)")
        print(f"Resources with endpoints extracted: {len(roothost_policies + template_policies + hardcoded_policies)}")
        print(f"Resources with backend fallback: {len(backend_only)}")
        
        return {
            'total_apis_searched': len(all_apis),
            'total_apis_processed': len(set(d['api_id'] for d in data)),
            'total_resources': len(data),
            'success_rate': success_rate,
            'roothost_policies': len(roothost_policies),
            'operation_policies': len(operation_policies),
            'mediation_policies': len(mediation_policies)
        }

def main():
    print("WSO2 API Manager 4.2 - Policy Endpoint Extractor")
    print("Basic Authentication Only - Individual Resource Analysis")
    print("=" * 60)
    
    if len(sys.argv) > 1 and sys.argv[1] == "--create-config":
        create_config()
        return
    
    if not os.path.exists("policy_config.json"):
        print("Config file not found. Creating default...")
        create_config()
        print("Please update policy_config.json and run again")
        return
    
    try:
        start_time = datetime.now()
        client = WSO2APIManager()
        
        print(f"Connecting to: {client.base_url}")
        print(f"Username: {client.username}")
        print(f"Started at: {start_time.strftime('%Y-%m-%d %H:%M:%S')}")
        
        data, all_apis = client.process_all_apis()
        
        if data:
            output_file = client.config.get('output_csv', 'wso2_policy_endpoints.csv')
            client.save_to_csv(data, output_file)
            
            # Generate detailed report
            report_stats = client.generate_detailed_report(data, all_apis)
            
            end_time = datetime.now()
            duration = end_time - start_time
            
            print(f"\nTIMING INFORMATION:")
            print(f"Started: {start_time.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"Completed: {end_time.strftime('%Y-%m-%d %H:%M:%S')}")
            print(f"Duration: {duration}")
            print(f"Average time per API: {duration.total_seconds()/len(all_apis):.2f} seconds")
            
            print(f"\nOUTPUT FILES:")
            print(f"Main CSV data: {output_file}")
            
            print(f"\nEXTRACTION COMPLETED SUCCESSFULLY!")
            print(f"Found {report_stats['total_apis_searched']} APIs with {report_stats['total_resources']} total resources")
            print(f"Extracted {report_stats['roothost_policies']} RootHost policies")
            
            # Show sample of what was found
            roothost_samples = [d for d in data if 'roothost' in d.get('endpoint_type', '').lower()][:5]
            if roothost_samples:
                print(f"\nSample RootHost extractions:")
                for sample in roothost_samples:
                    print(f"  - {sample['api_name']} [{sample['resource_method']} {sample['resource_path']}]: {sample['current_endpoint']}")
            
        else:
            print("No data extracted. Check credentials and connectivity.")
    
    except Exception as e:
        print(f"Script failed: {str(e)}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    main()
